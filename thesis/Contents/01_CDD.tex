\chapter[CDD]{\Glsentrylong{CDD}}\label{chap:01}
% glsfmtlong

%\newglossaryentry{tld:com}{%
%    type=domain,
%    name=.com, 
%    description={Commercial entities}
%}

\setcounter{section}{-1}
\section{Abstract}

\subsection{Purpose}
Decoupling frontend from backend codebases increasing scalability in both\\server provisioning and feature addition. Unfortunately feature addition also\\requires significant duplication of validation, schemas, APIs, tests, mocks,\\and documentation.

The goal of \Glsentryfull{CDD} is to automate the duplication. In doing so, The Author claims a solution to the software-engineering problem from 1968.

\subsection{Method}
Compilers are written in each target language. The \Glsentryfull{AST} of the target language (or OpenAPI) is traversed, and emits one of: new boilerplate project; new OpenAPI schema; xor modified [existent] project. Only static code-generation is done with CDD.

\subsection{Result}
Assuming 4 languages (Swift: iOS, Java: Android, TypeScript\&HTML: web, Rust: backend), and addition~|~removal of a single field to a single model, speed-\\up is \(35\times\). Over the software development lifecycle CDD is expected to contin-\\uously provide exponential speedup in development with a correspondent in-\\crease in quality.

\subsection{Conclusion}
Without tradeoffs, development speed and quality can be exponentially increased without using nonstandard languages or frameworks. The speedup is so great that new use-cases become possible, like inverting control to the non-developer, empowering their extension of the system, whilst still enabling developers to optimise all parts.

\subsection{Translational Relevance}
Pertinent case studies include: replacing NoSQL with SQL for an online survey project (user defines the survey/schema, this creates a database table, middleware, and frontends); expanding this survey project with multi-form workflows; split-\\ting/joining projects depending on use-case (e.g., split a social networking project into a series of independent projects for messages, groups, news, \&etc.); and building an \glsentryfull{ERP} platform without the usual requ-\\isite 10s of millions of dollars and development decade.

\pagebreak

\section{Introduction}
The software engineering problem was stated most famously in the 1968 NATO-sponsored conference\ldots~the argument this chapter focusses on is McIlroy's mass-production of mass-customisable software components\cite{mcilroyMassProducedSoftwareComponents1968}.

Roy Fielding's famous 2002 thesis\cite{Fielding:2002:PDM:514183.514185} defined \GlsXtrExpandedFmt{REST}, which over the past 20-years has become the most popular architecture for exposing software projects for consumption by other software projects. Key advantages of this architecture include: language independence; protocol agnosticism; frontends and backends can evolve independently of each other (so long as exposed/consumed interface remain consistent); vertical scalability; and the flexibility to scale different \mbox{-ends} different (e.g., deploy frontend to a \glsentryfull{CDN}, one back-\\end to a GPU server, and other backend to a low-cost CPU server).

\glsentryfull{SQL} was invented in 1974\cite{chamberlinSEQUELStructuredEnglish1974}. \glsentryshort{SQL} databases have been highly optimised over the decades, and are especially performant when \texttt{JOIN}s are rare. Inversion of control systems, where the user is defining the form, will have a large number of requisite \texttt{JOIN}s for \texttt{INSERT}, \texttt{SELECT}, \&etc.

Compilers have been in use since [at least] 1967\cite{Mccarthy67correctnessof}, and primarily focus on translating between a high level language (e.g., Rust) and a lower level language (e.g., assembly). A subset of compilers are `transpilers', which convert between high-level languages.

% a major strength of LLVM is its versatility, flexibility, reusability

It is uncommon to use the one language (\textit{lingua franca}) and framework for all frontends and backends. Each \glsentryfull{OS} vendor has their own recommended language \& framework to use to target their platform.

Quality software can be objectively defined by: consistency; modularity; inter-operability; maintainability (are there developers familiar?); extensibility; versa-\\tility; flexibility; reusability; test-ability (and test coverage); docs (and doc cover-\\age); and scalability (or, more generally: resource utilisation).

Existing solutions tradeoff between the following: quality and vendor recommen-\\dation\ldots~usually to speedup development.

The primary goal of \glsentryshort{CDD} is to gain a logarithmic reduction in development time with a corresponding increase in quality: without tradeoffs.

\section{Methods}
Compilers are written in each target language. This increases long-term mainten-\\ance viability, as new language constructs are more likely to be added if its in the language itself (and some languages\textemdash{}like TypeScript and Python\textemdash{}have officially maintained \texttt{ast} parser/emitters builtin to their respective distributions).

Once a language is selected, this methodology follows:
\begin{enumerate}
    \item[0.] Choose a maintained \texttt{ast} library (prioritise: official vendor maintained \& open-source);
    \item Develop boilerplate for installable package, \glsentryfull{SDK}, \glsentryfull{CLI}, and test;
    \item Publish open-source to Microsoft's GitHub (currently the most popular place for code hosting et al.);
    \item Author mocks, including full boilerplate project(s);
    \item Implement and test parsers (integrating and expanding mocks);
    \item Implement and test emitters (integrating and expanding mocks);
    \item Release package(s) and host documentation on website.
\end{enumerate}

Then this new language is integrated into multi-language testing; alongside the compilers already created.

Finally, all compilers are conformed to \glsentryfull{RPC} interfaces, for use in \glsentryfullpl{IDE}; include the custom web-centric one to demonstrate \glsentryshort{CDD}.

\section{Design}

\subsection{Python}
The first Python version supported all (6) vendor maintained versions.\cite{marksCddpython}

\subsubsection{Unexpected advantages}

During development some new opportunities presented itself, namely translating betwixt:
\begin{itemize}
    \item Different docstring formats;
    \item Types in docstring and type comment versus the newly supported [semant-\\ically valid] type annotations
\end{itemize}

\ldots{}and inferring types through static analysis of the surrounding context. These additional features enabled \texttt{cdd-python} to modify tens of thousands of lines of other peoples codebases (which were subsequently proferred as patches~|~pull-requests and merged).

In addition to these important use-cases, a focus on intralanguage\textemdash{}rather than just exolanguage\textemdash{}was in the forefront, facilitating synchronisation of:

\begin{itemize}
    \item \glsentryfull{POPC};
    \item Python functions and methods;
    \item \glsentryfull{ORM} \texttt{class} for most popular \glsentryshort{ORM} library;
    \item \glsentryshort{ORM} schema-defining function call for most popular \glsentryshort{ORM} library;
    \item \glsentryfull{CLI} with builtin functionality (\texttt{argparse})\ldots{} which furthermore enables [dynamic] \glsentryfull{GUI} gen-\\eration with a 3rd-party [open-source] library.
\end{itemize} 

\subsection{Rust}

\subsubsection{Unexpected advantages}
Porting a traditionally lower performant language (like Java) into a low level system language like Rust is sped up via \glsentryshort{CDD}.

\subsection{Swift}

\subsection{Java}

\subsection{Kotlin}

\subsection{TypeScript}
TypeScript has only one implementation, from its vendor (Microsoft), and has inbuilt \glsentryshort{AST} parsing and emission.

\subsection{C++}
LLVM makes a popular open-source multi-language multi-target compiler that has good tooling support for accessing and modifying \glsentryshortpl{AST}.

\subsubsection{Unexpected advantages}
Porting a traditionally lower performant language (like Java) into a low level system language like C++ is sped up via \glsentryshort{CDD}. Additionally, the lack of reflection in C++ makes the \glsentryshort{CDD} particularly useful in introspecting \texttt{class}es and\\\texttt{struct}s.

\subsection{C}

The LLVM dependent C++ compiler was extended with different input mocks, but remained in C++.

\subsubsection{Unexpected advantages}
Porting a traditionally lower performant language (like Java) into a low level system language like C is sped up via \glsentryshort{CDD}

Additionally, the lack of reflection in C makes the \glsentryshort{CDD} particularly useful in introspecting \texttt{struct}s.

Also, the lack of [builtin] automatic memory management means that dealloc-\\ations become tiresome (one can't do: \texttt{for property in struct\_obj \{ dealloc property \}})\ldots~but with \glsentryshort{CDD} one can generate the \texttt{free} calling functions.

Finally, the C CDD can generate client libraries for arbitrary OpenAPI schema exposing public APIs, which is far more powerful than doing the same in any other language, as [almost] every language has a way of interfacing to C via \glsentryfull{FFI} or similar lower overhead mechanisms.


\section{Usage}

\section{Results}

\section{Discussion}

\section{Conclusion}


\bibliographystyle{IEEEtranN}
\bibliography{Thesis}

\printglossary[type=cdd]
